# Nestjs + Prisma databases benchmark
Проект для тестирования производительности баз данных, используемых в Nestjs + Prisma.

Что используется в этом репо:
* NestJS `9.0.0`
* Prisma `4.7.1`
* Platform fastify  `9.2.1`
* PostgreSQL `15.1`
* MongoDB `6.0.1`
## Исследуемые кейсы и сценарии
Сравнение не реляционной и реляционной db (mongodb, postgres).
- [ ] Поиск
  - [ ] по нескольким значениям
  - [ ] по одному значению
  - [ ] по enum
  - [ ] полнотекстовый поиск
- [ ] Performance
  - [ ] Сравнение производительности
    - [ ] с использованием связей (1:1, 1:n, n:n)
    - [ ] без использования связей
  - [ ] Замер производительности при
    - [ ] записи всех данных в базу из kinopoiskdev api
    - [ ] чтении
    - [ ] удалении
- [ ] Влияние индексов на производительность
- [ ] Изучение запросов которые отправляет ORM в базу данных для
  - [ ] Mongo
  - [ ] Postgres

## Модель базы данных
### Postgres
![Postgres](./docs/images/pg-erd.svg)
Конфигурация кластера:
* Временно используется 1 экземпляр. 

___
### Mongodb
![Mongodb](./docs/images/mongo-erd.svg)
Конфигурация кластера:  
* Config Server (3 member replica set): `configsvr01`, `configsvr02`, `configsvr03`
* 3 Shards (each a 3 member PSS replica set):
  * `shard01-a`, `shard01-b`, `shard01-c` 
  * `shard02-a`, `shard02-b`, `shard02-c` 
  * `shard03-a`, `shard03-b`, `shard03-c`
* 2 Routers (mongos): `router01`, `router02`

![Config](https://raw.githubusercontent.com/minhhungit/mongodb-cluster-docker-compose/master/images/sharding-and-replica-sets.png)

**Конфигурация была позаимствована из [этого репозитория](https://github.com/minhhungit/mongodb-cluster-docker-compose).**


## Тестирование
### Добавление персон в базу данных c использование метода upsert.
Цель тестирования: сравнить производительность метода upsert в базах данных mongodb и postgresql при загрузке 5000000 персон с помощью метода upsert, по 100 персон синхронно. Метрикой измерения является время, потраченное на загрузку.

## Результаты тестирования
Это не все результаты, а всего лишь данные для показательности.
| База данных | Время, мс |
| --- | --- |
| mongodb | 1645 |
| mongodb | 1066 |
| mongodb | 1446 |
| mongodb | 1514 |
| mongodb | 1278 |
| mongodb | 1254 |
| mongodb | 1320 |
| mongodb | 1261 |
| mongodb | 1351 |
| mongodb | 1345 |
| mongodb | 1153 |
| mongodb | 1160 |
| postgresql | 4244 |
| postgresql | 4577 |
| postgresql | 6429 |
| postgresql | 6735 |
| postgresql | 6570 |
| postgresql | 5563 |
| postgresql | 5007 |
| postgresql | 4685 |
| postgresql | 4613 |
| postgresql | 5174 |
| postgresql | 5160 |
- - -

По результатам тестирования можно сделать следующие выводы:

- Метод upsert в базе данных mongodb работает быстрее, чем в базе данных postgresql. Среднее время загрузки в mongodb составило *1308* мс, в то время как в postgresql - *5473* мс.
- При сравнении результатов тестов между собой можно отметить, что время загрузки в mongodb варьируется в небольшом диапазоне, в то время как в postgresql время загрузки существенно отличается от теста к тесту. 

В целом, метод upsert в базе данных mongodb оказался более производительным, чем в базе данных postgresql. Однако, стоит учитывать, что результаты тестирования могут быть субъективны и зависеть от множества факторов.

Так же стоит отметить, что postgres оказался менее устойчивым к нагрузкам, и небольшой увеличение количества данных приводило к падению базы. В mongodb это происходило только после нескольких часов такой нагрузки, а postgres мог упасть уже спустя 5 минут. Но 100 персон оказались самым оптимальным значением и обе базы работали стабильно. Это происходило до тех пор пока не было сожрано почти 100% процессора. Что привело к этому я не могу сказать. Но оба приложения приводят к этому спустя короткое время.

## Наблюдения
Большая нагрузка приводит к тому, что mongodb не справляется с ней и все данные в базе становятся неконсистентными, что приводит к потере всех данных.
Данная проблема проявилась при попытке записать 10000 записей в базу данных.

Образ mongodb: `prismagraphql/mongo-single-replica:4.4.3-bionic`.
Он реализует простую репликацию на основе одного экземпляра mongodb. Вероятно это и стало причиной потери данных.
